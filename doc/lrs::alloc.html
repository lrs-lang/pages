<!DOCTYPE html><html><head><meta charset="utf-8" /> 
                    <link rel="stylesheet" type="text/css" href="style.css" /><title>Module lrs::alloc</title></head><body><h1>Module <a href="./lrs.html">lrs</a>::<a href="./lrs::alloc.html">alloc</a></h1><p>Memory allocation</p><h2>Description</h2><p>This module contains memory allocators and the <a href="./lrs::alloc::Allocator.html">Allocator</a> trait implemented by them.</p><h2>Types</h2><table><thead><tr><th>Kind</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td class="trait_hl">Trait</td>
                    <td><a href="./lrs::alloc::Allocator.html">Allocator</a></td><td><p>Allocators.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::alloc::Bda.html">Bda</a></td><td><p>The brain-dead allocator</p></td></tr><tr><td class="typedef_hl">Typedef</td>
                    <td><a href="./lrs::alloc::FbHeap.html">FbHeap</a></td><td></td></tr><tr><td class="typedef_hl">Typedef</td>
                    <td><a href="./lrs::alloc::Heap.html">Heap</a></td><td></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::alloc::Libc.html">Libc</a></td><td><p>The libc allocator</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::alloc::NoMem.html">NoMem</a></td><td><p>Heap without memory backing it</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::alloc::TaAlloc.html">TaAlloc</a></td><td><p>Throw-away allocator.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::alloc::TaPool.html">TaPool</a></td><td><p>The memory pool of TaAllo.</p></td></tr></tbody></table><h2>Functions</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::alloc::empty_ptr.html">empty_ptr</a></td><td><p>Returns a non-null pointer that points to a valid address and has pointer alignment.</p></td></tr></tbody></table><h2>Constants</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::alloc::MAX_SIZE.html">MAX_SIZE</a></td><td><p>The maximum size of an allocation</p></td></tr></tbody></table><h2>Remarks</h2><p>The maximum size of an allocation is limited to the maximum value that can be represented in an <code>isize</code>. This limit is checked by the allocators and allocation will fail if a too-large allocation is requested. The limit is also available through the <a href="./lrs::alloc::MAX_SIZE.html">MAX_SIZE</a> constant.</p><h3><code>Heap</code> and <code>FbHeap</code></h3><p>This module contains two type definitions that affect the default behavior of lrs. The <a href="./lrs::alloc::Heap.html">Heap</a> allocator is the default allocator used by types that have an allocator argument. For example, <code>Vec&lt;T&gt;</code> is the same as <code>Vec&lt;T, Heap&gt;</code>. The <a href="./lrs::alloc::FbHeap.html">FbHeap</a> allocator is the allocator used by functions that don't allocate in the common case and fall back to allocating if they have to. For example, <code>File::open</code> will try to construct a null-terminated path argument on the stack but falls back to allocating with the <a href="./lrs::alloc::FbHeap.html">FbHeap</a> allocator if the path is too long.</p><h3>Jemalloc</h3><p>The Jemalloc allocator is only available if lrs was compiled with the <code>jemalloc</code> option.</p><h2>Examples</h2><p>The following example performs a simple allocate-store-read-free operation.</p><pre>unsafe {
    let mem: *mut u8 = try!(Bda::allocate());
    *mem = 1;
    println!("{}", *mem);
    Bda::free(mem);
}</pre></body></html>