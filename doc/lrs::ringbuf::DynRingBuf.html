<!DOCTYPE html><html><head><meta charset="utf-8" /> 
                    <link rel="stylesheet" type="text/css" href="style.css" /><title>Struct lrs::ringbuf::DynRingBuf</title></head><body><h1>Struct <a href="./lrs.html">lrs</a>::<a href="./lrs::ringbuf.html">ringbuf</a>::<a href="./lrs::ringbuf::DynRingBuf.html">DynRingBuf</a></h1><p>A resizable ring buffer.</p><h2>Syntax</h2><pre>struct DynRingBuf&lt;T, Heap = <a href="./lrs::alloc::Libc.html">Libc</a>&gt;
    where Heap: <a href="./lrs::alloc::Allocator.html">Allocator</a>,
{
    /* private fields */
}</pre><h2>Static methods</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::ringbuf::DynRingBuf::buffered.html">buffered</a></td><td><p>Creates a ring buffer which is backed by borrowed memory.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::new.html">new</a></td><td><p>Creates a new ring buffer.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::with_capacity.html">with_capacity</a></td><td><p>Creates a new ring buffer and reserves a certain amount of space for it.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::with_pool.html">with_pool</a></td><td><p>Creates a new ring buffer with a memory pool.</p></td></tr></tbody></table><h2>Methods</h2><table><thead><tr><th>Receiver</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code class="no_break">&self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::available.html">available</a></td><td><p>Returns the number of available but unused slots.</p></td></tr><tr><td><code class="no_break">&self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::capacity.html">capacity</a></td><td><p>Returns the capacity of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::clear.html">clear</a></td><td></td></tr><tr><td><code class="no_break">&self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::iter.html">iter</a></td><td><p>Creates an iterator over the elements in the ringbuffer.</p></td></tr><tr><td><code class="no_break">&self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::len.html">len</a></td><td><p>Returns the number of elements in the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::pop_left.html">pop_left</a></td><td><p>Removes an element from the left end of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::pop_right.html">pop_right</a></td><td><p>Removes an element from the rght end of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::push_left.html">push_left</a></td><td><p>Appends an element to the left end of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::push_right.html">push_right</a></td><td><p>Appends an element to the right end of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::reserve.html">reserve</a></td><td><p>Reserves memory for additional elements.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::try_push_left.html">try_push_left</a></td><td><p>Tries to append an element to the right end of the ring buffer.</p></td></tr><tr><td><code class="no_break">&mut self</code></td><td><a href="./lrs::ringbuf::DynRingBuf::try_push_right.html">try_push_right</a></td><td><p>Tries to append an element to the right end of the ring buffer.</p></td></tr></tbody></table><h2>Trait implementations</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::ringbuf::DynRingBuf::Debug.html">Debug</a></td><td><p>Objects that can be formatted in a "debug" form.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::Drop.html">Drop</a></td><td><p>Objects with a destructor.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::Eq.html">Eq</a> (2 times)</td><td><p>Objects that implement the binary <code>==</code> and <code>!=</code> operators.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::Index.html">Index</a></td><td><p>Objects that implement the immutable subscript operator.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::IndexMut.html">IndexMut</a></td><td><p>Objects that implement the mutable subscript operator.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::MaybeClone.html">MaybeClone</a></td><td><p>Objects that can be duplicated.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::Send.html">Send</a></td><td><p>Objects whose ownership can be moved from one thread to another.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::Sync.html">Sync</a></td><td><p>Objects that allow immutable access from threads other than their owning thread.</p></td></tr><tr><td><a href="./lrs::ringbuf::DynRingBuf::UndefState.html">UndefState</a></td><td><p>Types that are not valid when they contain certain bit patterns.</p></td></tr></tbody></table></body></html>