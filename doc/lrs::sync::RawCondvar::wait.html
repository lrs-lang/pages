<!DOCTYPE html><html><head><meta charset="utf-8" /> 
                    <link rel="stylesheet" type="text/css" href="style.css" /><title>Method lrs::sync::RawCondvar::wait</title></head><body><h1>Method <a href="./lrs.html">lrs</a>::<a href="./lrs::sync.html">sync</a>::<a href="./lrs::sync::RawCondvar.html">RawCondvar</a>::<a href="./lrs::sync::RawCondvar::wait.html">wait</a></h1><p>Atomically unlocks a lock guard and waits for a signal on this condvar before re-locking the lock.</p><h2>Syntax</h2><pre>impl <a href="./lrs::sync::RawCondvar.html">RawCondvar</a> {
    fn wait(&self, guard: <a href="./lrs::sync::LockGuard.html">LockGuard</a>&lt;'a&gt;) -> <a href="./lrs::sync::LockGuard.html">LockGuard</a>&lt;'a&gt;
}</pre><h2>Arguments</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>guard</td><td><p>The lock guard to be unlocked.</p></td><tr></tbody></table><h2>Return value</h2><p>Returns a guard created by re-locking the lock of the guard argument.</p><h2>Remarks</h2><p>While the condition variable is in use, the condition variable can only be used with the same lock. The condition variable is in use while there are users waiting on it. If the condition variable is used with another a lock, the process is aborted.</p></body></html>