<!DOCTYPE html><html><head><meta charset="utf-8" /> 
                    <link rel="stylesheet" type="text/css" href="style.css" /><title>Module lrs::signal</title></head><body><h1>Module <a href="./lrs.html">lrs</a>::<a href="./lrs::signal.html">signal</a></h1><p>Signal handling.</p><h2>Sub-modules</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::signal::flags.html">flags</a></td><td><p>Flags for signalfds and signal handlers.</p></td></tr><tr><td><a href="./lrs::signal::signals.html">signals</a></td><td><p>Known signal constants.</p></td></tr></tbody></table><h2>Types</h2><table><thead><tr><th>Kind</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td class="enum_hl">Enum</td>
                    <td><a href="./lrs::signal::SigHandler.html">SigHandler</a></td><td><p>A signal handler.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::SigInfo.html">SigInfo</a></td><td><p>Information about a received signal.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::Sigfd.html">Sigfd</a></td><td><p>A signalfd.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::SigfdFlags.html">SigfdFlags</a></td><td><p>Flags that can be used when creating a Sigfd.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::SigfdInfo.html">SigfdInfo</a></td><td><p>Information about a signal received via a <code>Sigfd</code>.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::Signal.html">Signal</a></td><td><p>A signal.</p></td></tr><tr><td class="struct_hl">Struct</td>
                    <td><a href="./lrs::signal::Sigset.html">Sigset</a></td><td><p>A set of signals.</p></td></tr></tbody></table><h2>Functions</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="./lrs::signal::block_signal.html">block_signal</a></td><td><p>Blocks a signal from this thread.</p></td></tr><tr><td><a href="./lrs::signal::block_signals.html">block_signals</a></td><td><p>Blocks a set of signals from this thread.</p></td></tr><tr><td><a href="./lrs::signal::blocked_signals.html">blocked_signals</a></td><td><p>Returns the set of signals that are blocked by this thread.</p></td></tr><tr><td><a href="./lrs::signal::pending_signals.html">pending_signals</a></td><td><p>Returns the set of blocked signals that are currently blocked from this thread.</p></td></tr><tr><td><a href="./lrs::signal::send.html">send</a></td><td><p>Sends a signal to a process.</p></td></tr><tr><td><a href="./lrs::signal::send_to_thread.html">send_to_thread</a></td><td><p>Sends a signal to a thread.</p></td></tr><tr><td><a href="./lrs::signal::set_blocked_signals.html">set_blocked_signals</a></td><td><p>Sets the set of signals that are blocked from this thread.</p></td></tr><tr><td><a href="./lrs::signal::set_handler.html">set_handler</a></td><td><p>Sets the handler of a signal.</p></td></tr><tr><td><a href="./lrs::signal::suspend_with.html">suspend_with</a></td><td><p>Replaces the set of blocked signals and suspends the calling thread until a signal handler is invoked.</p></td></tr><tr><td><a href="./lrs::signal::unblock_signal.html">unblock_signal</a></td><td><p>Unblocks a signal from this thread.</p></td></tr><tr><td><a href="./lrs::signal::unblock_signals.html">unblock_signals</a></td><td><p>Unblocks a set of signals from this thread.</p></td></tr><tr><td><a href="./lrs::signal::wait.html">wait</a></td><td><p>Suspends the calling thread until a certain signal arrives.</p></td></tr><tr><td><a href="./lrs::signal::wait_timeout.html">wait_timeout</a></td><td><p>Suspends the calling thread until a certain signal arrives or a timeout expires.</p></td></tr></tbody></table><h2>Remarks</h2><p>Signals can be in one of three states:</p><ul><li><p>Unblocked</p></li><li><p>Blocked</p></li><li><p>Ignored</p></li></ul><p>Note that <code>Ignored</code> is a state that applies to the whole process while <code>Blocked</code> only applies to a single thread. If an ignored signal is sent to a thread or process, it is discarded.</p><p>If a signal is sent to a thread and the thread has the signal blocked, it is queued until the signal unblocks it or retrieves it in some other way. The same principle applies if a signal is sent to a process and all threads have the signal blocked.</p><p>If a signal is sent to a thread that has the signal unblocked or to a process where at least one thread has the signal unblocked, one of the following actions is taken:</p><ul><li><p>The process is terminated</p></li><li><p>The process is terminated and a core-dump is generated</p></li><li><p>The process is stopped</p></li><li><p>A signal handler is invoked</p></li></ul><p>By default, signal handlers are invoked on the stack of the thread that handles the signal. It is possible to use a separate stack which is necessary to handle invalid address access caused by stack overflow.</p><h2>See also</h2><ul><li><p><a href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7)</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/nptl.7.html">nptl(7)</a></p></li></ul></body></html>